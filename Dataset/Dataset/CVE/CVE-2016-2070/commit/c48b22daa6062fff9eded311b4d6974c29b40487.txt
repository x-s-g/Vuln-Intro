@@ -5670,7 +5670,10 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 		tcp_fast_path_on(tp);
 		break;
 
-	case TCP_FIN_WAIT1:
+	case TCP_FIN_WAIT1: {
+		struct dst_entry *dst;
+		int tmo;
+
 		/* If we enter the TCP_FIN_WAIT1 state and we are a
 		 * Fast Open socket and this is the first acceptable
 		 * ACK we have received, this would have acknowledged
@@ -5689,48 +5692,47 @@ int tcp_rcv_state_process(struct sock *sk, struct sk_buff *skb,
 			reqsk_fastopen_remove(sk, req, false);
 			tcp_rearm_rto(sk);
 		}
-		if (tp->snd_una == tp->write_seq) {
-			struct dst_entry *dst;
+		if (tp->snd_una != tp->write_seq)
+			break;
 
-			tcp_set_state(sk, TCP_FIN_WAIT2);
-			sk->sk_shutdown |= SEND_SHUTDOWN;
+		tcp_set_state(sk, TCP_FIN_WAIT2);
+		sk->sk_shutdown |= SEND_SHUTDOWN;
 
-			dst = __sk_dst_get(sk);
-			if (dst)
-				dst_confirm(dst);
+		dst = __sk_dst_get(sk);
+		if (dst)
+			dst_confirm(dst);
 
-			if (!sock_flag(sk, SOCK_DEAD)) {
-				/* Wake up lingering close() */
-				sk->sk_state_change(sk);
-			} else {
-				int tmo;
-
-				if (tp->linger2 < 0 ||
-				    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
-				     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {
-					tcp_done(sk);
-					NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
-					return 1;
-				}
+		if (!sock_flag(sk, SOCK_DEAD)) {
+			/* Wake up lingering close() */
+			sk->sk_state_change(sk);
+			break;
+		}
 
-				tmo = tcp_fin_time(sk);
-				if (tmo > TCP_TIMEWAIT_LEN) {
-					inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);
-				} else if (th->fin || sock_owned_by_user(sk)) {
-					/* Bad case. We could lose such FIN otherwise.
-					 * It is not a big problem, but it looks confusing
-					 * and not so rare event. We still can lose it now,
-					 * if it spins in bh_lock_sock(), but it is really
-					 * marginal case.
-					 */
-					inet_csk_reset_keepalive_timer(sk, tmo);
-				} else {
-					tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);
-					goto discard;
-				}
-			}
+		if (tp->linger2 < 0 ||
+		    (TCP_SKB_CB(skb)->end_seq != TCP_SKB_CB(skb)->seq &&
+		     after(TCP_SKB_CB(skb)->end_seq - th->fin, tp->rcv_nxt))) {
+			tcp_done(sk);
+			NET_INC_STATS_BH(sock_net(sk), LINUX_MIB_TCPABORTONDATA);
+			return 1;
+		}
+
+		tmo = tcp_fin_time(sk);
+		if (tmo > TCP_TIMEWAIT_LEN) {
+			inet_csk_reset_keepalive_timer(sk, tmo - TCP_TIMEWAIT_LEN);
+		} else if (th->fin || sock_owned_by_user(sk)) {
+			/* Bad case. We could lose such FIN otherwise.
+			 * It is not a big problem, but it looks confusing
+			 * and not so rare event. We still can lose it now,
+			 * if it spins in bh_lock_sock(), but it is really
+			 * marginal case.
+			 */
+			inet_csk_reset_keepalive_timer(sk, tmo);
+		} else {
+			tcp_time_wait(sk, TCP_FIN_WAIT2, tmo);
+			goto discard;
 		}
 		break;
+	}
 
 	case TCP_CLOSING:
 		if (tp->snd_una == tp->write_seq) {
